package userInterface.renderWindow;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

import javax.swing.JPanel;

/**
 * Provides a 3D view of the world, with locations
 * that are presented from a side on perspective.
 *
 *
 *
 * @author Pauline Kelly
 *
 */
public class RenderPanel extends JPanel {

	/* Application Canvas is a field - need one in
	 * the constructor for the Renderer.
	 *
	 * Need the location passed in - make a new
	 * renderer per location or use setLocation()?
	 *
	 * Need the 4 orientations - NSEW. A location
	 * that is entered from the north is shown with
	 * the view facing south.
	 *
	 * Locations in the distance are shown in the
	 * background.
	 *
	 */

	//For rendering objects within the game
	private List<GameObject> objects = new ArrayList<>();

	//For scaling, knowing how big the window is
	private int CANVAS_WIDTH;
	private int CANVAS_HEIGHT;

	private BufferedImage background;

	private Orientation currentOrientation;;
	private Tile[][] tiles;
	private Location playerLocation;

	//The panel to be rendered on

	/** Constructor. Takes the height and width of the canvas into account.
	 *
	 * @param wd Width of window
	 * @param ht Height of window
	 */
	public RenderPanel(BufferedImage background){
		CANVAS_WIDTH = this.getWidth();
		CANVAS_HEIGHT = this.getHeight();
		this.background = background;
	}

	/**
	 * The user has moved to a new position - now need to
	 * check what to render.
	 *
	 * 3 situations:
	 * 	a) 	They have moved forward a step in the same direction
	 *  b) 	They have moved backwards a step in the same direction
	 *  c) 	They have rotated left or right - check which
	 *  	then render the correct location.
	 *
	 *  Change the shift depending on what is chosen.
	 */
	public void update(Tile[][]tiles, Orientation o, Location playerLocation){
		this.tiles = tiles;
		currentOrientation = o;
		this.playerLocation = playerLocation;
	}

	/**
	 * Draws the background first, then draws the tiles and players.
	 */
	public void paintComponent(Graphics g){
		g.drawImage(background, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT, null);

		switch(currentOrientation){
		case NORTH:
			drawNorth(g);
			break;
		case SOUTH:
			drawSouth(g);
			break;
		case EAST:
			drawEast(g);
			break;
		case WEST:
			drawWest(g);
			break;
		default:
			throw new IllegalStateException("Orientation shouldn't get to this.");
		}

	}

	/**
	 * Draws the board as seen from the west.
	 *
	 * Isometric formula: 	x' = x - z
	 * 						y' = y + ((x + z)/2)
	 *
	 *x: x - y,
        y: (x / 2) + (y / 2) - z
		http://stackoverflow.com/questions/892811/drawing-isometric-game-worlds
        http://gamedev.stackexchange.com/questions/8151/how-should-i-sort-images-in-an-isometric-game-so-that-they-appear-in-the-correct
	 *
	 * http://flarerpg.org/tutorials/isometric_intro/
	 * @param g
	 */
	private void drawWest(Graphics g) {
		double x;
		double y;

		for (int i = 0; i < tiles.length; i++) {
			for (int j = 0; j < tiles[0].length; j++) {
				//Initially the current location
				double xOffset = playerLocation.getX();
				double yOffset = playerLocation.getY();

				x =  i + 5.5 - xOffset * 0.5 * WIDTH / 10;  //more complicated
				y =  i + 5.5 - yOffset * 0.5 * WIDTH / 10;

				Tile t = tiles[i][j];

				//the tiles also draws the object on it
				if(t != null){
					g.drawImage(t.draw(), (int) x, (int) y, WIDTH, HEIGHT, null);  //draw method also handles drawing items and players

					for(Image img: t.getObjects()){
						g.drawImage(img.draw(), (int) x, (int) y, WIDTH, HEIGHT, null);  //draw method also handles drawing items and players
					}
				}
				//otherwise skip it?
			}
		}

	}

	private void drawEast(Graphics g) {
		// TODO Auto-generated method stub

	}

	private void drawSouth(Graphics g) {
		// TODO Auto-generated method stub

	}

	private void drawNorth(Graphics g) {
		// TODO Auto-generated method stub

	}

	/**
	 * The Rendering method that does all the work.
	 * Draws the objects with the lowest Z first.
	 *
	 * @return
	 */
	private BufferedImage render(){
		return null;

	}

	/**
	 * Converts the bitmap to a BufferedImage to display on screen.
	 *
	 * @param color The 2D array of colours generated by the zBuffer.
	 * @return The image to display on screen.
	 */
	private BufferedImage convertBitmapToImage(Color[][] bitmap) {
		BufferedImage image = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT,
				BufferedImage.TYPE_INT_RGB);
		for (int x = 0; x < CANVAS_WIDTH; x++) {
			for (int y = 0; y < CANVAS_HEIGHT; y++) {
				Color col = bitmap[x][y];
				if (col == null) {
					col = Color.GRAY;
				}
				image.setRGB(x, y, col.getRGB());
			}
		}
		return image;
	}

	/**
	 * Load in the data for the new Location.
	 * Should probably use this method for each location.
	 *
	 * @param file
	 */
	private void onLoad(File file){

		Tile [][] tiles = new Tile[6][6];

		try {
			Scanner sc = new Scanner(file);

			while(sc.hasNextLine()){  //get the next item in the folder
				String line = sc.nextLine();
				Scanner scanLine = new Scanner(line);

				while(scanLine.hasNext()){
					String character = scanLine.next();
					System.out.print(character);
					Tile tile = null;

					switch(character){
					case "0":
						tile = new WallTile();
						break;
					case "1":
						tile = new GroundTile();
						break;
					default:
						throw new IllegalStateException("Illegal character parsed.");
					}


				}

			}
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
	}

}
