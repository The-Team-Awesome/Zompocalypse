package userInterface.renderWindow;

import java.awt.Color;
import java.awt.image.BufferedImage;
import java.io.File;
import java.util.ArrayList;
import java.util.List;

/**
 * Provides a 3D view of the world, with locations
 * that are presented from a side on perspective.
 *
 *
 *
 * @author Pauline Kelly
 *
 */
public class Renderer {

	/* Application Canvas is a field - need one in
	 * the constructor for the Renderer.
	 *
	 * Need the location passed in - make a new
	 * renderer per location or use setLocation()?
	 *
	 * Need the 4 orientations - NSEW. A location
	 * that is entered from the north is shown with
	 * the view facing south.
	 *
	 * Locations in the distance are shown in the
	 * background.
	 *
	 */

	//For rendering objects within the game
	private List<GameObject> objects = new ArrayList<>();
	private Location location;

	private Orientation currentOrientation = Orientation.NORTH;
	private Direction currentDir = Direction.STATIONARY;

	//For scaling, knowing how big the window is
	private int CANVAS_WIDTH;
	private int CANVAS_HEIGHT;

	//For rendering everything
	private Vector3D lightSource;

	//The shift in X and Y that changes when the character
	//moves
	private float shiftX = 1.0f;
	private float shiftY = 1.0f;

	/** Constructor. Takes the height and width of the canvas into account.
	 *
	 * @param wd Width of window
	 * @param ht Height of window
	 */
	public Renderer(int wd, int ht){
		CANVAS_WIDTH = wd;
		CANVAS_HEIGHT = ht;
	}

	/**
	 * The user has moved to a new position - now need to
	 * check what to render.
	 *
	 * 3 situations:
	 * 	a) 	They have moved forward a step in the same direction
	 *  b) 	They have moved backwards a step in the same direction
	 *  c) 	They have rotated left or right - check which
	 *  	then render the correct location.
	 *
	 *  Change the shift depending on what is chosen.
	 */
	private void keyPressed(Orientation o, Direction dir){
		//If the player has turned left or right, check for this.
		if(!(o.equals(currentOrientation))){
			switch(o){
			case NORTH:
				currentOrientation = Orientation.NORTH;
				break;
			case SOUTH:
				currentOrientation = Orientation.SOUTH;
				break;
			case EAST:
				currentOrientation = Orientation.EAST;
				break;
			case WEST:
				currentOrientation = Orientation.WEST;
				break;
			}
		}
		else {
			//the character has moved forwards or backwards
			switch(dir){
			case STATIONARY:
				currentDir = Direction.STATIONARY;
				break;
			case FORWARD:
				currentDir = Direction.FORWARD;
				break;
			case BACKWARD:
				currentDir = Direction.BACKWARD;
				break;
			}
		}

		//Finally, calculate the new object values and
		//render the scene
		render();
	}

	/**
	 * The Rendering method that does all the work.
	 * Draws the objects with the lowest Z first.
	 *
	 * @return
	 */
	private BufferedImage render(){
		ZBuffer zBuffer = initialiseZBuffer();
		zBuffer.setColor(new Color [CANVAS_WIDTH][CANVAS_HEIGHT]);
		zBuffer.setDepth(new float [CANVAS_WIDTH][CANVAS_HEIGHT]);  //set this to infinity

		for(int x = 0; x < CANVAS_WIDTH; x++){
			for(int y = 0; y < CANVAS_HEIGHT; y++){
				zBuffer.depth[x][y] = Float.POSITIVE_INFINITY;
			}
		}

		return convertBitmapToImage(zBuffer.color);
	}

	/**
	 * Converts the bitmap to a BufferedImage to display on screen.
	 *
	 * @param color The 2D array of colours generated by the zBuffer.
	 * @return The image to display on screen.
	 */
	private BufferedImage convertBitmapToImage(Color[][] bitmap) {
		BufferedImage image = new BufferedImage(CANVAS_WIDTH, CANVAS_HEIGHT,
				BufferedImage.TYPE_INT_RGB);
		for (int x = 0; x < CANVAS_WIDTH; x++) {
			for (int y = 0; y < CANVAS_HEIGHT; y++) {
				Color col = bitmap[x][y];
				if (col == null) {
					col = Color.GRAY;
				}
				image.setRGB(x, y, col.getRGB());
			}
		}
		return image;
	}

	private ZBuffer initialiseZBuffer(){
		ZBuffer zBuffer = new ZBuffer();

		zBuffer.setColor(new Color [CANVAS_WIDTH][CANVAS_HEIGHT]);
		zBuffer.setDepth(new float [CANVAS_WIDTH][CANVAS_HEIGHT]);  //set this to infinity

		for(int x = 0; x < CANVAS_WIDTH; x++){
			for(int y = 0; y < CANVAS_HEIGHT; y++){
				zBuffer.depth[x][y] = Float.POSITIVE_INFINITY;
			}
		}

		return zBuffer;
	}

	/**
	 * Load in the data for the new Location.
	 * Should probably use this method for each location.
	 *
	 * @param file
	 */
	private void onLoad(File file){
		//reads in the Location data from the file.
	}

}
